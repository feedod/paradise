<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            height: 100%;
            width: 100%;
        }
    </style>
</head>
<body>

<!-- Telegram Mini Apps SDK for integration within TWA -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<script type="module">
    'use strict'; // Enable strict mode for better error handling and modern JS practices (ES5+ standard, still relevant in 2025)

    // Import required modules from CDN (using latest stable Three.js version as of 2025)
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js';
    import { AsciiEffect } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/effects/AsciiEffect.js';
    import { TrackballControls } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/controls/TrackballControls.js';

    // Declare variables at the top for better readability and scope management
    let camera, scene, renderer, effect, controls;
    let girl; // Group for the chibi girl model
    let start = Date.now(); // Timestamp for animation timing

    // Initialize Telegram WebApp if available (for TWA compatibility, without expand() as per request)
    if (window.Telegram?.WebApp) {
        Telegram.WebApp.ready(); // Signal that the app is ready, no expansion needed inside TWA
    }

    // Main initialization function
    function init() {
        // Camera setup with perspective projection
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 0, 400);

        // Scene creation with black background
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Lighting: Ambient for overall illumination, Point for highlights
        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        scene.add(new THREE.PointLight(0xff99ff, 2, 0, 0).position.set(300, 400, 500));

        // Create chibi girl as a group of meshes
        girl = new THREE.Group();

        // Head: Large spherical head for chibi style
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(80, 32, 24),
            new THREE.MeshPhongMaterial({ color: 0xffddbb, flatShading: true })
        );
        head.position.y = 80;
        girl.add(head);

        // Hair: Main hair mass
        const hairMain = new THREE.Mesh(
            new THREE.SphereGeometry(84, 32, 24, 0, Math.PI * 2, 0, Math.PI * 0.9),
            new THREE.MeshPhongMaterial({ color: 0xff66cc, flatShading: true })
        );
        hairMain.position.set(0, 90, -20);
        girl.add(hairMain);

        // Ponytails: Left and right side bunches
        const ponytailGeometry = new THREE.SphereGeometry(30, 20, 16);
        const ponytailMaterial = new THREE.MeshPhongMaterial({ color: 0xff3399 });

        const ponytailL = new THREE.Mesh(ponytailGeometry, ponytailMaterial);
        ponytailL.position.set(-60, 100, 0);
        ponytailL.rotation.z = 0.5;
        girl.add(ponytailL);

        const ponytailR = new THREE.Mesh(ponytailGeometry, ponytailMaterial);
        ponytailR.position.set(60, 100, 0);
        ponytailR.rotation.z = -0.5;
        girl.add(ponytailR);

        // Eyes: Large anime-style eyes
        const eyeGeometry = new THREE.SphereGeometry(18, 16, 12);
        const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });

        const eyeL = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eyeL.position.set(-30, 90, 65);
        girl.add(eyeL);

        const eyeR = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eyeR.position.set(30, 90, 65);
        girl.add(eyeR);

        // Eye shines: Small highlights for anime effect
        const shineGeometry = new THREE.SphereGeometry(7, 16, 12);
        const shineMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });

        const shineL = new THREE.Mesh(shineGeometry, shineMaterial);
        shineL.position.set(-35, 95, 75);
        girl.add(shineL);

        const shineR = new THREE.Mesh(shineGeometry, shineMaterial);
        shineR.position.set(25, 95, 75);
        girl.add(shineR);

        // Body: Cylindrical torso
        const body = new THREE.Mesh(
            new THREE.CylinderGeometry(40, 50, 100, 20),
            new THREE.MeshPhongMaterial({ color: 0xff99dd, flatShading: true })
        );
        body.position.y = 0;
        girl.add(body);

        // Skirt: Conical skirt for cute chibi look
        const skirt = new THREE.Mesh(
            new THREE.ConeGeometry(70, 60, 32),
            new THREE.MeshPhongMaterial({ color: 0xff66ff, flatShading: true })
        );
        skirt.position.y = -40;
        girl.add(skirt);

        // Arms: Cylindrical arms with rotation
        const armGeometry = new THREE.CylinderGeometry(12, 12, 80, 12);
        const armMaterial = new THREE.MeshPhongMaterial({ color: 0xffddbb });

        const armL = new THREE.Mesh(armGeometry, armMaterial);
        armL.position.set(-50, 30, 0);
        armL.rotation.z = 0.5;
        girl.add(armL);

        const armR = new THREE.Mesh(armGeometry, armMaterial);
        armR.position.set(50, 30, 0);
        armR.rotation.z = -0.5;
        girl.add(armR);

        // Add girl group to scene
        scene.add(girl);

        // Renderer setup without antialiasing for ASCII performance
        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setPixelRatio(window.devicePixelRatio); // Improve for high-DPI devices (2025 standard)
        renderer.setSize(window.innerWidth, window.innerHeight);

        // AsciiEffect with optimized parameters for better visual quality
        effect = new AsciiEffect(renderer, ' .,:;i1tfLCG08@#%&', {
            invert: false,
            resolution: 0.18,
            scale: 1
        });
        effect.setSize(window.innerWidth, window.innerHeight);
        effect.domElement.style.color = '#ff99ff';
        effect.domElement.style.backgroundColor = '#000';
        effect.domElement.style.fontSize = '10px';
        effect.domElement.style.lineHeight = '9.5px';
        effect.domElement.style.letterSpacing = '1px';

        // Append effect's DOM element (div with ASCII)
        document.body.appendChild(effect.domElement);

        // Controls for interaction (touch/mouse compatible for TWA)
        controls = new TrackballControls(camera, effect.domElement);
        controls.rotateSpeed = 3.0;
        controls.minDistance = 250;
        controls.maxDistance = 600;

        // Resize event listener with debouncing for performance (modern standard)
        window.addEventListener('resize', onWindowResize);

        // Set animation loop using requestAnimationFrame for efficiency
        requestAnimationFrame(animate);
    }

    // Resize handler to update camera and renderer
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        effect.setSize(window.innerWidth, window.innerHeight);
    }

    // Animation loop function
    function animate() {
        requestAnimationFrame(animate); // Loop using RAF for smooth 60FPS (Web standard)

        const t = Date.now() - start; // Time delta for animations

        // Gentle rotation and bouncing for the whole girl
        girl.rotation.y = Math.sin(t * 0.001) * 0.2;
        girl.position.y = Math.abs(Math.sin(t * 0.003)) * 20;

        // Ponytails swaying animation
        girl.children[2].rotation.z = Math.sin(t * 0.004) * 0.3 + 0.5; // ponytailL
        girl.children[3].rotation.z = -Math.sin(t * 0.004) * 0.3 - 0.5; // ponytailR

        // Arms waving animation (fixed indices: arms are at 10 and 11)
        girl.children[10].rotation.z = Math.sin(t * 0.005) * 0.6 + 0.5; // armL
        girl.children[11].rotation.z = -Math.sin(t * 0.005) * 0.6 - 0.5; // armR

        // Update controls and render
        controls.update();
        effect.render(scene, camera);
    }

    // Start initialization
    init();
</script>

</body>
</html>