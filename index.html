<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; style-src 'self' 'unsafe-inline'; script-src 'self' https:; connect-src 'self' https:; media-src 'self' https: blob:">
    <title>Airi Companion</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.x/dist/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display@latest/dist/cubism4.min.js"></script>
    <style>
        :root {
            --tg-bg-color: #000000;
            --tg-text-color: #ffffff;
            --tg-hint-color: #999999;
            --tg-secondary-bg: #1c1c1e;
            --tg-accent: #2481cc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: var(--tg-bg-color);
            color: var(--tg-text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            position: fixed;
        }

        #app {
            width: 100%;
            height: 100%;
            position: relative;
            isolation: isolate;
        }

        #avatar-container {
            width: 100%;
            height: 100%;
            position: absolute;
            z-index: 1;
        }

        #voice-indicator {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%) scale(0);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: var(--tg-accent);
            opacity: 0;
            transition: transform 300ms cubic-bezier(0.34, 1.56, 0.64, 1), 
                        opacity 200ms ease;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        #voice-indicator.active {
            transform: translateX(-50%) scale(1);
            opacity: 0.9;
        }

        #voice-indicator::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: inherit;
            animation: voicePulse 1.5s ease-out infinite;
        }

        #voice-indicator::before {
            content: 'ðŸŽ¤';
            font-size: 32px;
            position: relative;
            z-index: 2;
        }

        @keyframes voicePulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 0; }
        }

        #status-notification {
            position: absolute;
            top: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: var(--tg-secondary-bg);
            backdrop-filter: blur(20px);
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transition: transform 300ms ease, opacity 200ms ease;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #status-notification.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        #debug-stats {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 11px;
            font-family: 'Menlo', 'Monaco', monospace;
            color: #00ff88;
            z-index: 1000;
            display: none;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        #debug-stats.visible {
            display: block;
        }

        .notification {
            position: absolute;
            bottom: 240px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--tg-secondary-bg);
            backdrop-filter: blur(30px);
            padding: 12px 20px;
            border-radius: 16px;
            font-size: 15px;
            max-width: 280px;
            text-align: center;
            opacity: 0;
            transition: all 300ms cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
        }

        @media (max-height: 700px) {
            #voice-indicator {
                bottom: 100px;
                width: 70px;
                height: 70px;
            }
            .notification {
                bottom: 180px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="avatar-container"></div>
        <div id="voice-indicator"></div>
        <div id="status-notification"></div>
        <div id="debug-stats"></div>
        <div class="notification" id="system-notification"></div>
    </div>

<script type="module">
class AiriSystem {
    static instance = null;

    static getInstance() {
        if (!AiriSystem.instance) {
            AiriSystem.instance = new AiriSystem();
        }
        return AiriSystem.instance;
    }

    constructor() {
        this.tg = window.Telegram?.WebApp;
        this.pixiApp = null;
        this.live2dModel = null;
        this.avatarManager = new AvatarManager();
        this.voiceService = new VoiceService();
        this.interactionHandler = new InteractionHandler();
        this.systemState = {
            isSpeaking: false,
            isListening: false,
            currentEmotion: 'neutral',
            modelScale: 0.18,
            modelPosition: { x: 0, y: 0 }
        };

        this.initPromise = this.initialize();
    }

    async initialize() {
        try {
            await this.initTelegram();
            await this.initGraphics();
            await this.initAvatar();
            this.setupEventHandlers();
            this.startSystemLoops();
            this.showStatus('Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð° Ð³Ð¾Ñ‚Ð¾Ð²Ð°');
        } catch (error) {
            this.handleFatalError(error);
        }
    }

    async initTelegram() {
        if (!this.tg) return;
        
        this.tg.ready();
        this.tg.expand();
        this.tg.disableVerticalSwipes();
        this.tg.setHeaderColor('secondary_bg_color');
        this.tg.setBackgroundColor('bg_color');
        
        if (this.tg.isVersionAtLeast('6.9')) {
            this.tg.requestFullscreen();
        }
        
        const themeParams = this.tg.themeParams || {};
        document.documentElement.style.setProperty('--tg-bg-color', themeParams.bg_color || '#000000');
        document.documentElement.style.setProperty('--tg-text-color', themeParams.text_color || '#ffffff');
        document.documentElement.style.setProperty('--tg-secondary-bg', themeParams.secondary_bg_color || '#1c1c1e');
        document.documentElement.style.setProperty('--tg-accent', themeParams.button_color || '#2481cc');
    }

    async initGraphics() {
        const canvas = document.createElement('canvas');
        canvas.id = 'live2d-canvas';
        
        this.pixiApp = new PIXI.Application({
            view: canvas,
            backgroundAlpha: 0,
            resizeTo: window,
            powerPreference: 'high-performance',
            antialias: true,
            resolution: Math.min(window.devicePixelRatio, 2),
            autoDensity: true
        });

        const container = document.getElementById('avatar-container');
        container.appendChild(this.pixiApp.view);
        
        new ResizeObserver(() => {
            this.pixiApp.resize();
            this.avatarManager.centerModel();
        }).observe(container);
    }

    async initAvatar() {
        const modelConfig = {
            id: 'hiyori',
            name: 'Hiyori',
            url: 'https://cdn.jsdelivr.net/gh/guansss/pixi-live2d-display/test/assets/hiyori/hiyori_pro_t10.model3.json'
        };

        this.live2dModel = await PIXI.live2d.Live2DModel.from(modelConfig.url, {
            autoInteract: false,
            autoUpdate: false
        });

        this.live2dModel.scale.set(this.systemState.modelScale);
        this.live2dModel.visible = true;
        this.pixiApp.stage.addChild(this.live2dModel);

        this.avatarManager.setModel(this.live2dModel);
        this.avatarManager.centerModel();
    }

    setupEventHandlers() {
        window.addEventListener('keydown', (event) => {
            if (event.shiftKey && event.key === 'D') {
                document.getElementById('debug-stats').classList.toggle('visible');
            }
            if (event.shiftKey && event.key === 'R') {
                this.avatarManager.centerModel();
            }
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                cancelAnimationFrame(this.animationFrame);
            } else {
                this.startAnimationLoop();
            }
        });

        if (this.tg?.onEvent) {
            this.tg.onEvent('themeChanged', () => {
                const theme = this.tg.themeParams;
                document.documentElement.style.setProperty('--tg-bg-color', theme.bg_color);
                document.documentElement.style.setProperty('--tg-text-color', theme.text_color);
            });
        }
    }

    startSystemLoops() {
        this.startAnimationLoop();
        this.startBehaviorLoop();
        this.startStatsLoop();
    }

    startAnimationLoop() {
        const animate = (time) => {
            this.animationFrame = requestAnimationFrame(animate);
            
            if (this.live2dModel) {
                this.live2dModel.update(this.pixiApp.ticker.deltaTime);
                this.avatarManager.updateEyeTracking();
                
                if (this.systemState.isSpeaking) {
                    this.avatarManager.updateLipSync();
                }
            }
            
            this.pixiApp.render();
        };
        
        animate(0);
    }

    startBehaviorLoop() {
        setInterval(() => {
            if (!this.systemState.isSpeaking && !this.systemState.isListening) {
                this.avatarManager.triggerRandomBehavior();
            }
        }, 8000 + Math.random() * 7000);
    }

    startStatsLoop() {
        let frameCount = 0;
        let lastTime = performance.now();
        
        setInterval(() => {
            const currentTime = performance.now();
            const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
            
            const stats = document.getElementById('debug-stats');
            if (stats.classList.contains('visible')) {
                const memory = performance.memory ? 
                    ` | MEM: ${Math.round(performance.memory.usedJSHeapSize / 1048576)}MB` : '';
                stats.textContent = `FPS: ${fps}${memory}`;
            }
            
            frameCount = 0;
            lastTime = currentTime;
        }, 1000);
    }

    async processVoiceCommand(audioData) {
        try {
            this.systemState.isListening = true;
            this.showVoiceIndicator(true);
            this.avatarManager.setEmotion('listening');
            
            const text = await this.voiceService.recognizeSpeech(audioData);
            
            if (text) {
                this.showNotification(`Ð’Ñ‹: "${text}"`, 2000);
                const response = await this.generateResponse(text);
                await this.speakResponse(response);
            }
            
        } catch (error) {
            this.showStatus('ÐžÑˆÐ¸Ð±ÐºÐ° Ñ€Ð°ÑÐ¿Ð¾Ð·Ð½Ð°Ð²Ð°Ð½Ð¸Ñ');
        } finally {
            this.systemState.isListening = false;
            this.showVoiceIndicator(false);
            this.avatarManager.setEmotion('neutral');
        }
    }

    async generateResponse(userInput) {
        const responses = [
            `Ð¯ ÑÐ»Ñ‹ÑˆÐ°Ð»Ð°: "${userInput}". Ð Ð°ÑÑÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð¿Ð¾Ð´Ñ€Ð¾Ð±Ð½ÐµÐµ!`,
            `Ð˜Ð½Ñ‚ÐµÑ€ÐµÑÐ½Ð¾! "${userInput}" â€” Ñ‡Ñ‚Ð¾ Ð²Ñ‹ Ð¸Ð¼ÐµÐµÑ‚Ðµ Ð² Ð²Ð¸Ð´Ñƒ?`,
            `Ð—Ð°Ð¿Ð¾Ð¼Ð½Ð¸Ð»Ð°: "${userInput}". Ð§ÐµÐ¼ ÐµÑ‰Ðµ Ð¼Ð¾Ð³Ñƒ Ð¿Ð¾Ð¼Ð¾Ñ‡ÑŒ?`,
            `ÐŸÐ¾Ð½ÑÐ»Ð° Ð²Ð°Ñ Ð½Ð°ÑÑ‡Ñ‘Ñ‚ "${userInput}". ÐŸÑ€Ð¾Ð´Ð¾Ð»Ð¶Ð¸Ð¼ Ñ€Ð°Ð·Ð³Ð¾Ð²Ð¾Ñ€?`
        ];
        
        return responses[Math.floor(Math.random() * responses.length)];
    }

    async speakResponse(text) {
        this.systemState.isSpeaking = true;
        this.avatarManager.setEmotion('speaking');
        
        try {
            const audioBuffer = await this.voiceService.synthesizeSpeech(text);
            await this.voiceService.playAudio(audioBuffer, (volume) => {
                this.avatarManager.updateLipAmplitude(volume);
            });
            
            this.showNotification(text, 3000);
            this.avatarManager.setEmotion('happy');
            
        } catch (error) {
            this.showStatus('ÐžÑˆÐ¸Ð±ÐºÐ° Ð²Ð¾ÑÐ¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð¸Ñ');
        } finally {
            this.systemState.isSpeaking = false;
            this.avatarManager.resetLipSync();
        }
    }

    showVoiceIndicator(show) {
        const indicator = document.getElementById('voice-indicator');
        indicator.classList.toggle('active', show);
    }

    showStatus(message, duration = 2000) {
        const element = document.getElementById('status-notification');
        element.textContent = message;
        element.classList.add('visible');
        
        setTimeout(() => {
            element.classList.remove('visible');
        }, duration);
    }

    showNotification(message, duration = 3000) {
        const element = document.getElementById('system-notification');
        element.textContent = message;
        element.classList.add('show');
        
        setTimeout(() => {
            element.classList.remove('show');
        }, duration);
    }

    handleFatalError(error) {
        console.error('System failure:', error);
        this.showStatus('ÐšÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ° ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹');
        
        if (this.tg?.HapticFeedback) {
            this.tg.HapticFeedback.notificationOccurred('error');
        }
    }
}

class AvatarManager {
    constructor() {
        this.model = null;
        this.eyeTarget = { x: 0, y: 0 };
        this.lipAmplitude = 0;
        this.currentExpression = 'neutral';
        this.expressionMap = new Map([
            ['neutral', 'F00'],
            ['happy', 'F01'],
            ['surprised', 'F04'],
            ['listening', 'F06'],
            ['speaking', 'F01']
        ]);
    }

    setModel(model) {
        this.model = model;
    }

    centerModel() {
        if (!this.model || !this.model.parent) return;
        
        const screen = this.model.parent;
        this.model.position.set(
            screen.width / 2,
            screen.height / 1.7
        );
    }

    updateEyeTracking() {
        if (!this.model) return;
        
        const cursorPos = InteractionHandler.getInstance().getNormalizedCursor();
        this.eyeTarget.x += (cursorPos.x - this.eyeTarget.x) * 0.1;
        this.eyeTarget.y += (cursorPos.y - this.eyeTarget.y) * 0.1;
        
        try {
            const core = this.model.internalModel?.coreModel;
            if (core) {
                core.setParameterValueById('ParamAngleX', this.eyeTarget.x * 15);
                core.setParameterValueById('ParamAngleY', this.eyeTarget.y * 15);
            }
        } catch (error) {
        }
    }

    setEmotion(emotion) {
        if (!this.model || this.currentExpression === emotion) return;
        
        const expressionId = this.expressionMap.get(emotion) || 'F00';
        
        try {
            this.model.expression(expressionId);
            this.currentExpression = emotion;
            
            if (emotion !== 'speaking') {
                setTimeout(() => {
                    if (this.currentExpression === emotion) {
                        this.model.expression('F00');
                        this.currentExpression = 'neutral';
                    }
                }, 2000);
            }
        } catch (error) {
        }
    }

    updateLipSync() {
        if (!this.model) return;
        
        const amplitude = Math.min(this.lipAmplitude * 1.5, 1);
        const mouthValue = Math.sin(Date.now() * 0.01) * amplitude * 0.5 + amplitude * 0.3;
        
        try {
            const core = this.model.internalModel?.coreModel;
            if (core) {
                core.setParameterValueById('ParamMouthOpenY', mouthValue);
                core.setParameterValueById('ParamMouthForm', amplitude * 0.5);
            }
        } catch (error) {
        }
    }

    updateLipAmplitude(volume) {
        this.lipAmplitude = volume;
    }

    resetLipSync() {
        this.lipAmplitude = 0;
        
        try {
            const core = this.model.internalModel?.coreModel;
            if (core) {
                core.setParameterValueById('ParamMouthOpenY', 0);
                core.setParameterValueById('ParamMouthForm', 0);
            }
        } catch (error) {
        }
    }

    triggerRandomBehavior() {
        if (!this.model || Math.random() > 0.7) return;
        
        const behaviors = ['blink', 'glance', 'smile'];
        const behavior = behaviors[Math.floor(Math.random() * behaviors.length)];
        
        switch (behavior) {
            case 'blink':
                this.triggerBlink();
                break;
            case 'glance':
                this.triggerGlance();
                break;
            case 'smile':
                this.setEmotion('happy');
                break;
        }
    }

    triggerBlink() {
        try {
            this.model.expression('F05');
            setTimeout(() => {
                if (this.model && this.currentExpression === 'neutral') {
                    this.model.expression('F00');
                }
            }, 120);
        } catch (error) {
        }
    }

    triggerGlance() {
        this.eyeTarget.x = (Math.random() - 0.5) * 2;
        this.eyeTarget.y = (Math.random() - 0.5) * 2;
    }
}

class VoiceService {
    constructor() {
        this.audioContext = null;
        this.recognition = null;
        this.initSpeechRecognition();
    }

    initSpeechRecognition() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const Recognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            this.recognition = new Recognition();
            this.recognition.continuous = false;
            this.recognition.interimResults = false;
            this.recognition.lang = 'ru-RU';
            this.recognition.maxAlternatives = 1;
        }
    }

    async recognizeSpeech(audioData) {
        if (!this.recognition) {
            throw new Error('Speech recognition not available');
        }

        return new Promise((resolve, reject) => {
            this.recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                resolve(transcript);
            };

            this.recognition.onerror = (event) => {
                reject(new Error(event.error));
            };

            this.recognition.onend = () => {
            };

            this.recognition.start();
        });
    }

    async synthesizeSpeech(text) {
        if (!window.speechSynthesis) {
            throw new Error('Speech synthesis not available');
        }

        return new Promise((resolve, reject) => {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'ru-RU';
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            utterance.onend = () => {
                resolve();
            };

            utterance.onerror = (event) => {
                reject(new Error(event.error));
            };

            window.speechSynthesis.speak(utterance);
        });
    }

    async playAudio(audioBuffer, onVolume) {
        if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        const source = this.audioContext.createBufferSource();
        source.buffer = audioBuffer;

        const analyser = this.audioContext.createAnalyser();
        analyser.fftSize = 256;
        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        source.connect(analyser);
        analyser.connect(this.audioContext.destination);

        const updateVolume = () => {
            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const volume = average / 255;
            onVolume(volume);
            requestAnimationFrame(updateVolume);
        };

        source.start();
        updateVolume();

        return new Promise((resolve) => {
            source.onended = () => {
                resolve();
            };
        });
    }
}

class InteractionHandler {
    static instance = null;

    static getInstance() {
        if (!InteractionHandler.instance) {
            InteractionHandler.instance = new InteractionHandler();
        }
        return InteractionHandler.instance;
    }

    constructor() {
        this.cursorPosition = { x: 0, y: 0 };
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };
        this.setupListeners();
    }

    setupListeners() {
        const container = document.getElementById('avatar-container');
        
        container.addEventListener('mousedown', this.handlePointerStart.bind(this));
        container.addEventListener('touchstart', this.handlePointerStart.bind(this), { passive: true });
        
        container.addEventListener('mousemove', this.handlePointerMove.bind(this));
        container.addEventListener('touchmove', this.handlePointerMove.bind(this), { passive: false });
        
        container.addEventListener('mouseup', this.handlePointerEnd.bind(this));
        container.addEventListener('touchend', this.handlePointerEnd.bind(this));
        
        container.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    handlePointerStart(event) {
        this.isDragging = true;
        const point = this.getEventPoint(event);
        this.dragStart = { x: point.x, y: point.y };
        
        const model = AiriSystem.getInstance().live2dModel;
        if (model) {
            this.dragStart.x -= model.position.x;
            this.dragStart.y -= model.position.y;
        }
        
        AiriSystem.getInstance().avatarManager.setEmotion('surprised');
    }

    handlePointerMove(event) {
        const point = this.getEventPoint(event);
        this.cursorPosition = this.normalizePoint(point);
        
        if (this.isDragging) {
            event.preventDefault();
            const model = AiriSystem.getInstance().live2dModel;
            if (model) {
                model.position.set(
                    point.x - this.dragStart.x,
                    point.y - this.dragStart.y
                );
            }
        }
    }

    handlePointerEnd(event) {
        if (!this.isDragging) {
            const point = this.getEventPoint(event);
            AiriSystem.getInstance().processVoiceCommand();
            AiriSystem.getInstance().avatarManager.setEmotion('happy');
        }
        this.isDragging = false;
    }

    getEventPoint(event) {
        if (event.type.includes('touch')) {
            const touch = event.touches[0] || event.changedTouches[0];
            return {
                x: touch.clientX * window.devicePixelRatio,
                y: touch.clientY * window.devicePixelRatio
            };
        }
        return {
            x: event.clientX * window.devicePixelRatio,
            y: event.clientY * window.devicePixelRatio
        };
    }

    normalizePoint(point) {
        const width = window.innerWidth * window.devicePixelRatio;
        const height = window.innerHeight * window.devicePixelRatio;
        
        return {
            x: (point.x / width) * 2 - 1,
            y: 1 - (point.y / height) * 2
        };
    }

    getNormalizedCursor() {
        return this.cursorPosition;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    AiriSystem.getInstance();
});

window.AiriSystem = AiriSystem;
</script>
</body>
</html>