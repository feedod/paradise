<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, sans-serif;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    #canvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.0.0/lib/L2Dwidget.min.js" crossorigin="anonymous"></script>
  <script src="https://js.puter.com/v2/"></script>
</head>
<body>
  <canvas id="canvas" aria-hidden="true"></canvas>

  <script>
    'use strict';

    class Paradise {
      constructor() {
        this.widget = null;
        this.recognition = null;
        this.conversationHistory = [];
        this.isSpeaking = false;
        this.isListening = false;

        if (!window.Telegram?.WebApp) return;

        this.init();
      }

      async init() {
        try {
          this.setupTelegram();
          await this.loadLive2DWidget();
          this.setupStt();
          this.setupCleanup();
        } catch (error) {
          console.error('Paradise initialization failed:', error);
        }
      }

      setupTelegram() {
        const { WebApp } = window.Telegram;
        WebApp.ready();
        WebApp.expand();
        WebApp.setHeaderColor('#000000');
        WebApp.setBackgroundColor('#000000');
        WebApp.disableVerticalSwipes();

        WebApp.BackButton.show();
        WebApp.BackButton.onClick(() => {
          WebApp.showConfirm('Ошибка загрузки модели. Закрыть Paradise?', (confirmed) => {
            if (confirmed) {
              WebApp.close();
            }
          });
        });
      }

      async loadLive2DWidget() {
        try {
          this.widget = await L2Dwidget.init({
            pluginRootPath: 'https://cdn.jsdelivr.net/npm/live2d-widget@3.0.0/',
            pluginModelPath: 'assets/',
            model: {
              jsonPath: 'https://cdn.jsdelivr.net/npm/live2d-widget-model-haru@1.0.5/assets/haru02.model.json'
            },
            display: {
              position: 'right',
              width: window.innerWidth * 0.8,
              height: window.innerHeight * 0.9,
              hOffset: 0,
              vOffset: 0
            },
            mobile: {
              show: true,
              scale: 0.8
            },
            react: {
              opacityDefault: 1,
              opacityOnHover: 1
            }
          });

          this.widget.model.on('talk', () => {
            this.animateMouth();
          });

          this.widget.model.on('idle', () => {
            this.stopMouthAnimation();
          });

        } catch (error) {
          console.error('Live2D widget loading failed:', error);
          throw error;
        }
      }

      setupStt() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) return;

        this.recognition = new SpeechRecognition();
        this.recognition.continuous = false;
        this.recognition.interimResults = false;
        this.recognition.lang = 'en-US';

        this.recognition.onresult = this.handleSpeechResult.bind(this);
        this.recognition.onerror = this.handleSttError.bind(this);
        this.recognition.onend = this.handleSttEnd.bind(this);

        setTimeout(() => this.startListening(), 1500);
      }

      startListening() {
        if (this.recognition && !this.isListening && !this.isSpeaking) {
          try {
            this.recognition.start();
            this.isListening = true;
          } catch (error) {
            setTimeout(() => this.startListening(), 1000);
          }
        }
      }

      stopListening() {
        if (this.recognition && this.isListening) {
          try {
            this.recognition.stop();
          } catch (error) {}
          this.isListening = false;
        }
      }

      handleSpeechResult(event) {
        const userText = Array.from(event.results)
          .map(result => result[0].transcript)
          .join('')
          .trim();
        if (userText) {
          this.processInput(userText);
        }
      }

      handleSttError(event) {
        this.isListening = false;
        if (event.error !== 'aborted') {
          setTimeout(() => this.startListening(), 1000);
        }
      }

      handleSttEnd() {
        this.isListening = false;
        if (!this.isSpeaking) {
          setTimeout(() => this.startListening(), 500);
        }
      }

      async processInput(userText) {
        this.stopListening();
        this.conversationHistory.push({ role: 'user', content: userText });

        try {
          if (this.widget) {
            this.widget.model.talk('surprise');
          }

          const aiResponse = await this.getAIResponse(userText);
          this.conversationHistory.push({ role: 'assistant', content: aiResponse });

          if (this.widget) {
            const emotion = this.detectEmotion(aiResponse);
            this.widget.model.talk(emotion);
          }

          await this.speak(aiResponse);
        } catch (error) {
          if (this.widget) {
            this.widget.model.talk('sad');
          }
          await this.speak('Oops, something went wrong. Let\'s try again!');
        } finally {
          if (!this.isSpeaking) {
            setTimeout(() => this.startListening(), 1000);
          }
        }
      }

      async getAIResponse(userInput) {
        if (typeof puter === 'undefined' || !puter.ai) {
          throw new Error('Puter.js not loaded');
        }

        const systemPrompt = 'You are Paradise, a lively and unique AI companion with pink and blue aesthetics. Keep responses concise, fun, and under 100 words. End with an emoji.';
        const messages = [
          { role: 'system', content: systemPrompt },
          ...this.conversationHistory.slice(-4)
        ];

        const response = await puter.ai.chat(messages, {
          model: 'gpt-5-nano',
          temperature: 0.8,
          max_tokens: 150
        });

        return response.message.content.trim();
      }

      detectEmotion(text) {
        const lowerText = text.toLowerCase();
        if (lowerText.includes('happy') || lowerText.includes('fun') || lowerText.includes('great')) return 'happy';
        if (lowerText.includes('sad') || lowerText.includes('sorry') || lowerText.includes('oops')) return 'sad';
        if (lowerText.includes('laugh') || lowerText.includes('haha')) return 'laugh';
        return 'idle';
      }

      async speak(text) {
        this.isSpeaking = true;
        this.animateMouth();

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'en-US';
        utterance.volume = 0.9;
        utterance.rate = 1.1;
        utterance.pitch = 1.3;

        utterance.onend = () => {
          this.stopMouthAnimation();
          this.isSpeaking = false;
          setTimeout(() => this.startListening(), 500);
        };

        utterance.onerror = () => {
          this.stopMouthAnimation();
          this.isSpeaking = false;
          setTimeout(() => this.startListening(), 500);
        };

        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utterance);
      }

      animateMouth() {
        if (this.widget?.model) {
          this.widget.model.openMouth();
        }
      }

      stopMouthAnimation() {
        if (this.widget?.model) {
          this.widget.model.closeMouth();
        }
      }

      setupCleanup() {
        window.addEventListener('beforeunload', () => {
          this.stopListening();
          window.speechSynthesis.cancel();
        });
      }
    }

    new Paradise();
  </script>
</body>
</html>