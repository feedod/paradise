<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, sans-serif;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    #canvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js" crossorigin="anonymous"></script>
  <script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/index.min.js" crossorigin="anonymous"></script>
  <script src="https://js.puter.com/v2/"></script>
</head>
<body>
  <canvas id="canvas" aria-hidden="true"></canvas>

  <script>
    'use strict';

    class Paradise {
      constructor() {
        this.model = null;
        this.recognition = null;
        this.mouthAnimationInterval = null;
        this.conversationHistory = [];
        this.isSpeaking = false;
        this.isListening = false;
        this.app = null;

        if (!window.Telegram?.WebApp) return;

        this.init();
      }

      async init() {
        try {
          this.setupTelegram();
          this.app = await this.setupPixi();
          await this.loadAndSetupModel();
          this.setupStt();
          this.startIdleLoop();
          this.setupCleanup();
        } catch (error) {
          console.error('Paradise initialization failed:', error);
        }
      }

      setupTelegram() {
        const { WebApp } = window.Telegram;
        WebApp.ready();
        WebApp.expand();
        WebApp.setHeaderColor('#000000');
        WebApp.setBackgroundColor('#000000');
        WebApp.disableVerticalSwipes();

        WebApp.BackButton.show();
        WebApp.BackButton.onClick(() => {
          WebApp.showConfirm('Do you want to close Paradise?', (confirmed) => {
            if (confirmed) {
              WebApp.close();
            }
          });
        });
      }

      async setupPixi() {
        const canvas = document.getElementById('canvas');
        const app = new PIXI.Application({
          view: canvas,
          autoStart: true,
          backgroundColor: 0x000000,
          resizeTo: window,
          resolution: window.devicePixelRatio || 1,
          autoDensity: true,
          antialias: true,
          powerPreference: 'high-performance',
          sharedTicker: false
        });

        window.addEventListener('resize', this.handleResize.bind(this), { passive: true });
        window.addEventListener('orientationchange', () => setTimeout(this.handleResize.bind(this), 0));

        return app;
      }

      async loadAndSetupModel() {
        const modelUrl = 'https://cdn.jsdelivr.net/gh/guansss/pixi-live2d-display/test/assets/haru/haru_greeter_t03.model3.json';
        this.model = await PIXI.live2d.Live2DModel.from(modelUrl, { autoUpdate: true });

        this.model.alpha = 1;
        this.model.visible = true;
        this.app.stage.addChild(this.model);
        this.app.stage.interactive = true;
        this.model.interactive = true;

        this.setupModelInteractions();
        this.updateTransform();
        this.startRandomIdle();
        this.setupEyeBlink();
      }

      setupModelInteractions() {
        this.model.on('hit', (hitAreas) => {
          if (hitAreas.includes('Body')) {
            this.triggerTapMotion();
            this.hapticFeedback();
          }
        });
      }

      triggerTapMotion() {
        if (this.model?.internalModel?.motionManager) {
          this.model.internalModel.motionManager.startRandomMotion('Tap');
        }
      }

      updateTransform() {
        if (!this.model || !this.app) return;
        this.model.position.set(this.app.renderer.width / 2, this.app.renderer.height / 2);
        const scale = Math.min(
          (this.app.renderer.width * 0.9) / this.model.width,
          (this.app.renderer.height * 0.9) / this.model.height
        );
        this.model.scale.set(scale);
      }

      handleResize() {
        this.updateTransform();
      }

      startRandomIdle() {
        if (this.model?.internalModel?.motionManager) {
          this.model.internalModel.motionManager.startRandomMotion('Idle');
        }
      }

      setupEyeBlink() {
        if (!this.model?.internalModel?.coreModel) return;
        const coreModel = this.model.internalModel.coreModel;
        setInterval(() => {
          if (!this.isSpeaking) {
            const blinkValue = Math.random() < 0.1 ? 0 : 1;
            coreModel.setParameterValueById('ParamEyeLOpen', blinkValue);
            coreModel.setParameterValueById('ParamEyeROpen', blinkValue);
          }
        }, 3000);
      }

      setupStt() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) return;

        this.recognition = new SpeechRecognition();
        this.recognition.continuous = false;
        this.recognition.interimResults = false;
        this.recognition.lang = 'en-US';

        this.recognition.onresult = this.handleSpeechResult.bind(this);
        this.recognition.onerror = this.handleSttError.bind(this);
        this.recognition.onend = this.handleSttEnd.bind(this);

        setTimeout(() => this.startListening(), 1500);
      }

      startListening() {
        if (this.recognition && !this.isListening && !this.isSpeaking) {
          try {
            this.recognition.start();
            this.isListening = true;
          } catch (error) {
            setTimeout(() => this.startListening(), 1000);
          }
        }
      }

      stopListening() {
        if (this.recognition && this.isListening) {
          try {
            this.recognition.stop();
          } catch (error) {}
          this.isListening = false;
        }
      }

      handleSpeechResult(event) {
        const userText = Array.from(event.results)
          .map(result => result[0].transcript)
          .join('')
          .trim();
        if (userText) {
          this.processInput(userText);
        }
      }

      handleSttError(event) {
        this.isListening = false;
        if (event.error !== 'aborted') {
          setTimeout(() => this.startListening(), 1000);
        }
      }

      handleSttEnd() {
        this.isListening = false;
        if (!this.isSpeaking) {
          setTimeout(() => this.startListening(), 500);
        }
      }

      async processInput(userText) {
        this.stopListening();
        this.conversationHistory.push({ role: 'user', content: userText });

        try {
          this.triggerEmotion('surprise');
          const aiResponse = await this.getAIResponse(userText);
          this.conversationHistory.push({ role: 'assistant', content: aiResponse });

          const emotion = this.detectEmotion(aiResponse);
          this.triggerEmotion(emotion);
          await this.speak(aiResponse);
        } catch (error) {
          this.triggerEmotion('sad');
          await this.speak('Oops, something went wrong. Let\'s try again!');
        } finally {
          if (!this.isSpeaking) {
            setTimeout(() => this.startListening(), 1000);
          }
        }
      }

      async getAIResponse(userInput) {
        if (typeof puter === 'undefined' || !puter.ai) {
          throw new Error('Puter.js not loaded');
        }

        const systemPrompt = 'You are Paradise, a lively and unique AI companion with pink and blue aesthetics. Keep responses concise, fun, and under 100 words. End with an emoji.';
        const messages = [
          { role: 'system', content: systemPrompt },
          ...this.conversationHistory.slice(-4)
        ];

        const response = await puter.ai.chat(messages, {
          model: 'gpt-5-nano',
          temperature: 0.8,
          max_tokens: 150
        });

        return response.message.content.trim();
      }

      detectEmotion(text) {
        const lowerText = text.toLowerCase();
        if (lowerText.includes('happy') || lowerText.includes('fun') || lowerText.includes('great')) return 'happy';
        if (lowerText.includes('sad') || lowerText.includes('sorry') || lowerText.includes('oops')) return 'sad';
        if (lowerText.includes('laugh') || lowerText.includes('haha')) return 'laugh';
        return 'neutral';
      }

      triggerEmotion(emotion) {
        if (!this.model?.internalModel) return;

        const expressions = {
          happy: 'f01',
          sad: 'f03',
          laugh: 'f02',
          surprise: 'f04',
          neutral: 'f00'
        };
        const expr = expressions[emotion] || 'f00';
        this.model.expression(expr);

        switch (emotion) {
          case 'laugh':
            this.animateLaughter();
            break;
          case 'sad':
            this.animateSad();
            break;
          default:
            this.startRandomIdle();
        }
      }

      animateLaughter() {
        if (this.model?.internalModel?.coreModel) {
          const coreModel = this.model.internalModel.coreModel;
          let laughCount = 0;
          const laughInterval = setInterval(() => {
            const mouthValue = Math.sin(Date.now() / 200) * 0.5 + 0.5;
            coreModel.setParameterValueById('PARAM_MOUTH_OPEN_Y', Math.abs(mouthValue));
            laughCount++;
            if (laughCount > 10) {
              clearInterval(laughInterval);
              coreModel.setParameterValueById('PARAM_MOUTH_OPEN_Y', 0);
            }
          }, 150);
        }
      }

      animateSad() {
        if (this.model?.internalModel?.motionManager) {
          this.model.internalModel.motionManager.startRandomMotion('Idle');
        }
      }

      async speak(text) {
        this.isSpeaking = true;
        this.animateMouth();

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'en-US';
        utterance.volume = 0.9;
        utterance.rate = 1.1;
        utterance.pitch = 1.3;

        utterance.onstart = () => {
          this.startRandomIdle();
        };

        utterance.onend = () => {
          this.stopMouthAnimation();
          this.isSpeaking = false;
          this.triggerEmotion('neutral');
          setTimeout(() => this.startListening(), 500);
        };

        utterance.onerror = () => {
          this.stopMouthAnimation();
          this.isSpeaking = false;
          setTimeout(() => this.startListening(), 500);
        };

        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utterance);
      }

      animateMouth() {
        if (this.mouthAnimationInterval) clearInterval(this.mouthAnimationInterval);
        this.mouthAnimationInterval = setInterval(() => {
          if (this.model?.internalModel?.coreModel) {
            const value = Math.abs(Math.sin(Date.now() / 150)) * 0.8;
            this.model.internalModel.coreModel.setParameterValueById('PARAM_MOUTH_OPEN_Y', value);
          }
        }, 100);
      }

      stopMouthAnimation() {
        if (this.mouthAnimationInterval) {
          clearInterval(this.mouthAnimationInterval);
          this.mouthAnimationInterval = null;
        }
        if (this.model?.internalModel?.coreModel) {
          this.model.internalModel.coreModel.setParameterValueById('PARAM_MOUTH_OPEN_Y', 0);
        }
      }

      startIdleLoop() {
        setInterval(() => {
          if (!this.isSpeaking && !this.isListening && this.model) {
            this.startRandomIdle();
          }
        }, 8000);
      }

      hapticFeedback() {
        const { WebApp } = window.Telegram;
        if (WebApp?.HapticFeedback) {
          WebApp.HapticFeedback.impactOccurred('light');
        }
      }

      setupCleanup() {
        window.addEventListener('beforeunload', () => {
          this.stopListening();
          window.speechSynthesis.cancel();
        });
      }
    }

    new Paradise();
  </script>
</body>
</html>