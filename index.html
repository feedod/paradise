<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <style>
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: manipulation;
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js?64"></script>
</head>
<body>
<script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.181.2/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/loaders/GLTFLoader.js';
    import { VRMUtils, VRMLoaderPlugin } from 'https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.4.4/dist/three-vrm.module.js';

    class VRMViewer {
        constructor() {
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.clock = null;
            this.vrm = null;
            this.mixer = null;
            this.controls = null;
            this.animationId = null;
            this.isInitialized = false;
            this.isDestroyed = false;

            this.init().catch(this.handleFatalError.bind(this));
        }

        async init() {
            if (this.isDestroyed) return;

            try {
                this.setupTelegram();
                await this.setupThreeJS();
                this.setupCamera();
                this.setupControls();
                this.setupLights();
                await this.loadModel();
                this.setupEventListeners();
                this.startRenderLoop();
                this.isInitialized = true;
            } catch (error) {
                this.handleFatalError(error);
                throw error;
            }
        }

        setupTelegram() {
            const webApp = window.Telegram?.WebApp;
            if (!webApp) return;

            try {
                webApp.ready();
                webApp.expand();
                webApp.enableClosingConfirmation();
                webApp.setBackgroundColor('#000000');
                webApp.setHeaderColor('#000000');
                webApp.disableVerticalSwipes();
            } catch (error) {
                console.warn('Telegram WebApp setup failed:', error);
            }
        }

        async setupThreeJS() {
            return new Promise((resolve, reject) => {
                try {
                    this.scene = new THREE.Scene();
                    
                    this.camera = new THREE.PerspectiveCamera(
                        35,
                        window.innerWidth / window.innerHeight,
                        0.1,
                        100
                    );

                    this.renderer = new THREE.WebGLRenderer({
                        antialias: true,
                        alpha: false,
                        powerPreference: 'high-performance'
                    });

                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    this.renderer.toneMappingExposure = 1.0;
                    this.renderer.shadowMap.enabled = true;
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                    document.body.appendChild(this.renderer.domElement);
                    
                    this.clock = new THREE.Clock();

                    resolve();
                } catch (error) {
                    reject(new Error(`ThreeJS setup failed: ${error.message}`));
                }
            });
        }

        setupCamera() {
            this.camera.position.set(0, 1.4, 2.2);
        }

        setupControls() {
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            this.controls.screenSpacePanning = false;
            this.controls.minDistance = 1.2;
            this.controls.maxDistance = 4.0;
            this.controls.minPolarAngle = Math.PI * 0.35;
            this.controls.maxPolarAngle = Math.PI * 0.65;
            this.controls.target.set(0, 1.35, 0);
            this.controls.update();
        }

        setupLights() {
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444488, 0.8);
            hemisphereLight.position.set(0, 20, 0);
            this.scene.add(hemisphereLight);

            const directionalLightMain = new THREE.DirectionalLight(0xfff0ea, 1.2);
            directionalLightMain.position.set(3, 5, 4);
            directionalLightMain.castShadow = true;
            directionalLightMain.shadow.mapSize.width = 2048;
            directionalLightMain.shadow.mapSize.height = 2048;
            directionalLightMain.shadow.camera.near = 0.5;
            directionalLightMain.shadow.camera.far = 50;
            directionalLightMain.shadow.camera.left = -10;
            directionalLightMain.shadow.camera.right = 10;
            directionalLightMain.shadow.camera.top = 10;
            directionalLightMain.shadow.camera.bottom = -10;
            this.scene.add(directionalLightMain);

            const directionalLightFill = new THREE.DirectionalLight(0xe0c3fc, 0.6);
            directionalLightFill.position.set(-4, 3, -3);
            this.scene.add(directionalLightFill);
        }

        async loadModel() {
            const loader = new GLTFLoader();
            loader.register(parser => new VRMLoaderPlugin(parser));

            const modelPath = 'https://github.com/mrdoob/three.js/raw/refs/heads/master/examples/models/gltf/Michelle.glb';

            try {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load(
                        modelPath,
                        resolve,
                        undefined,
                        reject
                    );
                });

                if (!gltf.userData.vrm) {
                    throw new Error('Invalid VRM model format');
                }

                const vrm = gltf.userData.vrm;
                
                VRMUtils.removeUnnecessaryJoints(vrm.scene);
                VRMUtils.rotateVRM0(vrm);

                this.vrm = vrm;
                this.scene.add(vrm.scene);

                this.centerModel(vrm.scene);

                if (vrm.lookAt) {
                    vrm.lookAt.target = this.camera;
                }

                if (vrm.expressionManager) {
                    vrm.expressionManager.setValue('happy', 0.4);
                }

                if (gltf.animations?.length > 0) {
                    this.mixer = new THREE.AnimationMixer(vrm.scene);
                    gltf.animations.forEach(clip => {
                        this.mixer.clipAction(clip).play();
                    });
                }

                this.triggerHapticFeedback('success');
            } catch (error) {
                throw new Error(`Model loading failed: ${error.message}`);
            }
        }

        centerModel(modelScene) {
            const box = new THREE.Box3().setFromObject(modelScene);
            const center = box.getCenter(new THREE.Vector3());
            modelScene.position.sub(center);
            modelScene.position.y -= box.min.y;
        }

        setupEventListeners() {
            const resizeHandler = () => {
                if (!this.camera || !this.renderer || this.isDestroyed) return;
                
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            };

            window.addEventListener('resize', resizeHandler, { passive: true });

            const visibilityHandler = () => {
                if (this.isDestroyed) return;

                if (document.hidden && this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                } else if (!document.hidden && this.isInitialized) {
                    this.startRenderLoop();
                }
            };

            document.addEventListener('visibilitychange', visibilityHandler);
        }

        startRenderLoop() {
            if (this.animationId || this.isDestroyed) {
                return;
            }

            const render = () => {
                if (this.isDestroyed) return;

                this.animationId = requestAnimationFrame(render);
                this.update();
                this.render();
            };

            render();
        }

        update() {
            if (this.isDestroyed) return;

            const delta = this.clock.getDelta();

            if (this.controls) {
                this.controls.update();
            }

            if (this.vrm) {
                this.vrm.update(delta);
            }

            if (this.mixer) {
                this.mixer.update(delta);
            }
        }

        render() {
            if (this.renderer && this.scene && this.camera && !this.isDestroyed) {
                this.renderer.render(this.scene, this.camera);
            }
        }

        triggerHapticFeedback(type) {
            const webApp = window.Telegram?.WebApp;
            if (!webApp?.HapticFeedback) return;

            try {
                switch (type) {
                    case 'success':
                        webApp.HapticFeedback.notificationOccurred('success');
                        break;
                    case 'error':
                        webApp.HapticFeedback.notificationOccurred('error');
                        break;
                    case 'warning':
                        webApp.HapticFeedback.notificationOccurred('warning');
                        break;
                }
            } catch (error) {
                console.warn('Haptic feedback failed:', error);
            }
        }

        handleFatalError(error) {
            console.error('Application fatal error:', error);
            
            this.triggerHapticFeedback('error');

            const webApp = window.Telegram?.WebApp;
            if (webApp) {
                try {
                    webApp.showAlert(`Ошибка загрузки: ${error.message}`);
                } catch (uiError) {
                    console.warn('UI error handling failed:', uiError);
                    alert(`Ошибка загрузки: ${error.message}`);
                }
            } else {
                alert(`Ошибка загрузки: ${error.message}`);
            }

            this.cleanup();
        }

        cleanup() {
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
            }

            if (this.mixer) {
                this.mixer.stopAllAction();
                this.mixer = null;
            }

            if (this.controls) {
                this.controls.dispose();
                this.controls = null;
            }

            if (this.vrm) {
                this.scene?.remove(this.vrm.scene);
                this.vrm = null;
            }

            if (this.renderer) {
                this.renderer.dispose();
                this.renderer.domElement?.remove();
                this.renderer = null;
            }

            if (this.scene) {
                this.scene.traverse(object => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
                this.scene = null;
            }

            this.camera = null;
            this.clock = null;
            this.isInitialized = false;
        }

        destroy() {
            this.isDestroyed = true;
            this.cleanup();
        }
    }

    let viewerInstance = null;

    const initializeApp = () => {
        if (viewerInstance) return;
        
        try {
            viewerInstance = new VRMViewer();
        } catch (error) {
            console.error('Failed to initialize VRM viewer:', error);
        }
    };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp, { once: true });
    } else {
        initializeApp();
    }

    window.addEventListener('beforeunload', () => {
        if (viewerInstance) {
            viewerInstance.destroy();
            viewerInstance = null;
        }
    }, { once: true });
</script>
</body>
</html>