<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
        }
    }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
            font-size: 14px;
        }
        
        .loader-spinner {
            width: 24px;
            height: 24px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 12px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loader">
        <div class="loader-spinner"></div>
        <span>Initializing AI...</span>
    </div>
    
    <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

    // ================= CONFIG =================
    const CONFIG = {
        MODEL_URL: './VRM1_Constraint_Twist_Sample.vrm',
        CAMERA_FOV: 40,
        CAMERA_POSITION: new THREE.Vector3(0, 1.2, 2.2),
        BREATH_SPEED: 0.5,
        BREATH_AMPLITUDE: 0.008,
        BLINK_MIN: 2,
        BLINK_MAX: 6,
        EYE_FOLLOW_SPEED: 0.2,
        HEAD_FOLLOW_SPEED: 0.1,
        IDLE_MOVEMENT_SPEED: 0.5
    };

    // ================= APP CORE ==============
    class AIAvatar {
        constructor() {
            this.scene = new THREE.Scene();
            this.clock = new THREE.Clock();
            this.vrm = null;
            this.input = { x: 0, y: 0 };
            this.eyeTarget = new THREE.Vector3(0, 1.6, -3);
            this.headTarget = new THREE.Quaternion();
            this.blinkTimer = 0;
            this.nextBlink = 0;
            this.breathPhase = 0;
            this.idleTime = 0;
            this.idleTarget = new THREE.Vector2(0, 0);
            
            this.init();
        }
        
        async init() {
            await this.setupRenderer();
            await this.setupScene();
            await this.loadModel();
            this.setupInput();
            this.hideLoader();
            this.animate();
        }
        
        async setupRenderer() {
            this.camera = new THREE.PerspectiveCamera(
                CONFIG.CAMERA_FOV,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            this.camera.position.copy(CONFIG.CAMERA_POSITION);
            
            this.renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            });
            
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            this.renderer.outputColorSpace = THREE.SRGBColorSpace;
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            this.renderer.domElement.id = 'canvas';
            document.body.appendChild(this.renderer.domElement);
            
            window.addEventListener('resize', () => this.onResize());
        }
        
        async setupScene() {
            // Ambient light
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambient);
            
            // Main light
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
            mainLight.position.set(2, 4, 2);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024;
            mainLight.shadow.mapSize.height = 1024;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            this.scene.add(mainLight);
            
            // Rim light
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(-2, 2, -2);
            this.scene.add(rimLight);
        }
        
        async loadModel() {
            return new Promise((resolve, reject) => {
                const loader = new GLTFLoader();
                loader.register((parser) => new VRMLoaderPlugin(parser));
                
                loader.load(
                    CONFIG.MODEL_URL,
                    (gltf) => {
                        this.vrm = gltf.userData.vrm;
                        
                        if (!this.vrm) {
                            reject(new Error('Invalid VRM model'));
                            return;
                        }
                        
                        // Optimize
                        VRMUtils.removeUnnecessaryVertices(gltf.scene);
                        VRMUtils.removeUnnecessaryJoints(gltf.scene);
                        
                        // Setup model
                        this.centerModel();
                        this.setupLookAt();
                        
                        // Add to scene
                        this.scene.add(this.vrm.scene);
                        
                        // Set initial blink timer
                        this.nextBlink = THREE.MathUtils.randFloat(CONFIG.BLINK_MIN, CONFIG.BLINK_MAX);
                        
                        console.log('AI Avatar loaded');
                        resolve();
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        document.getElementById('loader').querySelector('span').textContent = 
                            `Loading AI... ${percent}%`;
                    },
                    (error) => reject(error)
                );
            });
        }
        
        centerModel() {
            if (!this.vrm) return;
            
            const box = new THREE.Box3().setFromObject(this.vrm.scene);
            const size = new THREE.Vector3();
            box.getSize(size);
            
            // Scale to reasonable size
            const scale = 1.8 / size.y;
            this.vrm.scene.scale.multiplyScalar(scale);
            
            // Position at ground level
            this.vrm.scene.position.set(0, -1.0, 0);
        }
        
        setupLookAt() {
            if (!this.vrm?.lookAt) return;
            
            this.lookAtTarget = new THREE.Object3D();
            this.lookAtTarget.position.set(0, 1.5, -3);
            this.scene.add(this.lookAtTarget);
            
            this.vrm.lookAt.target = this.lookAtTarget;
        }
        
        setupInput() {
            const onMove = (clientX, clientY) => {
                this.input.x = (clientX / window.innerWidth) * 2 - 1;
                this.input.y = -((clientY / window.innerHeight) * 2 - 1);
                this.idleTime = 0;
            };
            
            const onEnd = () => {
                this.input.x = 0;
                this.input.y = 0;
            };
            
            // Touch
            document.addEventListener('touchstart', (e) => {
                e.preventDefault();
                onMove(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                onMove(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                e.preventDefault();
                onEnd();
            }, { passive: false });
            
            // Mouse
            document.addEventListener('mousedown', (e) => onMove(e.clientX, e.clientY));
            document.addEventListener('mousemove', (e) => {
                if (e.buttons === 1) onMove(e.clientX, e.clientY);
            });
            document.addEventListener('mouseup', onEnd);
            
            // Idle movement
            this.idleTarget.set(
                THREE.MathUtils.randFloat(-0.3, 0.3),
                THREE.MathUtils.randFloat(-0.2, 0.2)
            );
        }
        
        updateIdleMovement(deltaTime) {
            this.idleTime += deltaTime;
            
            if (this.idleTime > 5) {
                this.idleTarget.set(
                    THREE.MathUtils.randFloat(-0.3, 0.3),
                    THREE.MathUtils.randFloat(-0.2, 0.2)
                );
                this.idleTime = 0;
            }
            
            const idleX = THREE.MathUtils.lerp(
                this.input.x,
                this.idleTarget.x,
                Math.min(this.idleTime * CONFIG.IDLE_MOVEMENT_SPEED, 1)
            );
            
            const idleY = THREE.MathUtils.lerp(
                this.input.y,
                this.idleTarget.y,
                Math.min(this.idleTime * CONFIG.IDLE_MOVEMENT_SPEED, 1)
            );
            
            return { x: idleX, y: idleY };
        }
        
        updateBreathing(deltaTime) {
            this.breathPhase += deltaTime * CONFIG.BREATH_SPEED;
            const chest = this.vrm?.humanoid?.getNormalizedBoneNode('chest');
            
            if (chest) {
                chest.position.y = Math.sin(this.breathPhase) * CONFIG.BREATH_AMPLITUDE;
            }
        }
        
        updateBlink(deltaTime) {
            this.blinkTimer += deltaTime;
            
            if (this.blinkTimer >= this.nextBlink && this.vrm?.expressionManager) {
                this.vrm.expressionManager.setValue('blink', 1);
                
                setTimeout(() => {
                    if (this.vrm?.expressionManager) {
                        this.vrm.expressionManager.setValue('blink', 0);
                    }
                }, 100);
                
                this.blinkTimer = 0;
                this.nextBlink = THREE.MathUtils.randFloat(CONFIG.BLINK_MIN, CONFIG.BLINK_MAX);
            }
        }
        
        updateLookAt(deltaTime, inputX, inputY) {
            if (!this.vrm?.lookAt || !this.lookAtTarget) return;
            
            // Smooth eye following
            this.eyeTarget.x = THREE.MathUtils.lerp(
                this.eyeTarget.x,
                inputX * 1.5,
                CONFIG.EYE_FOLLOW_SPEED * deltaTime * 60
            );
            
            this.eyeTarget.y = THREE.MathUtils.lerp(
                this.eyeTarget.y,
                1.6 + inputY * 0.5,
                CONFIG.EYE_FOLLOW_SPEED * deltaTime * 60
            );
            
            // Update lookAt target
            this.lookAtTarget.position.lerp(this.eyeTarget, CONFIG.EYE_FOLLOW_SPEED * deltaTime * 60);
            
            // Head rotation
            const headRotation = new THREE.Quaternion().setFromEuler(
                new THREE.Euler(
                    inputY * 0.2,
                    inputX * 0.3,
                    0,
                    'XYZ'
                )
            );
            
            this.headTarget.slerp(headRotation, CONFIG.HEAD_FOLLOW_SPEED * deltaTime * 60);
            
            // Apply to VRM
            this.vrm.lookAt.update(deltaTime);
        }
        
        update(deltaTime) {
            if (!this.vrm) return;
            
            // Get input with idle movement
            const input = this.input.x === 0 && this.input.y === 0 
                ? this.updateIdleMovement(deltaTime)
                : this.input;
            
            // Update systems
            this.updateBreathing(deltaTime);
            this.updateBlink(deltaTime);
            this.updateLookAt(deltaTime, input.x, input.y);
            
            // Update VRM
            this.vrm.update(deltaTime);
        }
        
        hideLoader() {
            const loader = document.getElementById('loader');
            loader.style.opacity = '0';
            loader.style.transition = 'opacity 0.5s';
            
            setTimeout(() => {
                loader.style.display = 'none';
            }, 500);
        }
        
        onResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        animate() {
            requestAnimationFrame(() => this.animate());
            
            const deltaTime = this.clock.getDelta();
            this.update(deltaTime);
            this.renderer.render(this.scene, this.camera);
        }
    }

    // ================= INIT ====================
    // Wait for DOM
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            new AIAvatar().catch(console.error);
        });
    } else {
        new AIAvatar().catch(console.error);
    }
    </script>
</body>
</html>