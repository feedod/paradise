<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
      "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.4.2/lib/three-vrm.module.min.js"
    }
  }
  </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }

    canvas {
      display: block;
    }

    #loader {
      position: fixed;
      inset: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .loader-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>
<body>
  <div id="loader">
    <div class="loader-spinner"></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

    class AIAvatar {
      constructor() {
        this.scene = new THREE.Scene();
        this.clock = new THREE.Clock();

        this.vrm = null;
        this.input = { x: 0, y: 0 };
        this.eyeTarget = new THREE.Vector3(0, 1.6, -3);
        this.lookAtTarget = null;
        this.headTarget = new THREE.Quaternion();

        this.blinkTimer = 0;
        this.nextBlink = 0;

        this.breathPhase = 0;

        this.idleTime = 0;
        this.idleTarget = new THREE.Vector2();

        this.init();
      }

      async init() {
        await this.setupRenderer();
        await this.setupScene();
        await this.loadModel();
        this.setupInput();
        this.hideLoader();
        this.animate();
      }

      async setupRenderer() {
        this.camera = new THREE.PerspectiveCamera(
          40,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        );
        this.camera.position.set(0, 1.2, 2.2);

        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          powerPreference: 'high-performance'
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFShadowMap;

        document.body.appendChild(this.renderer.domElement);

        window.addEventListener('resize', () => this.onResize());
      }

      async setupScene() {
        this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainLight.position.set(2, 4, 2);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.set(1024, 1024);
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 50;
        this.scene.add(mainLight);

        this.scene.add(new THREE.DirectionalLight(0xffffff, 0.3).position.set(-2, 2, -2));
      }

      async loadModel() {
        const loader = new GLTFLoader();
        loader.register((parser) => new VRMLoaderPlugin(parser));

        const gltf = await loader.loadAsync('./VRM1_Constraint_Twist_Sample.vrm', (progress) => {
          const percent = Math.round((progress.loaded / progress.total) * 100);
          document.getElementById('loader').style.opacity = 1 - percent / 100;
        });

        this.vrm = gltf.userData.vrm;

        VRMUtils.removeUnnecessaryVertices(gltf.scene);
        VRMUtils.removeUnnecessaryJoints(gltf.scene);

        this.vrm.scene.position.y = -1.0;
        this.setupLookAt();

        this.scene.add(this.vrm.scene);

        this.nextBlink = THREE.MathUtils.randFloat(2, 6);
      }

      setupLookAt() {
        if (!this.vrm?.lookAt) return;

        this.lookAtTarget = new THREE.Object3D();
        this.lookAtTarget.position.set(0, 1.5, -3);
        this.scene.add(this.lookAtTarget);

        this.vrm.lookAt.target = this.lookAtTarget;
      }

      setupInput() {
        const onMove = (x, y) => {
          this.input.x = (x / window.innerWidth) * 2 - 1;
          this.input.y = -((y / window.innerHeight) * 2 - 1);
          this.idleTime = 0;
        };

        const onEnd = () => {
          this.input.x = 0;
          this.input.y = 0;
        };

        document.addEventListener('pointermove', (e) => {
          onMove(e.clientX, e.clientY);
        }, { passive: true });

        document.addEventListener('pointerdown', (e) => {
          onMove(e.clientX, e.clientY);
        }, { passive: true });

        document.addEventListener('pointerup', onEnd, { passive: true });
        document.addEventListener('pointerleave', onEnd, { passive: true });

        this.idleTarget.set(
          THREE.MathUtils.randFloat(-0.3, 0.3),
          THREE.MathUtils.randFloat(-0.2, 0.2)
        );
      }

      updateIdleMovement(delta) {
        this.idleTime += delta;

        if (this.idleTime > 5) {
          this.idleTarget.set(
            THREE.MathUtils.randFloat(-0.3, 0.3),
            THREE.MathUtils.randFloat(-0.2, 0.2)
          );
          this.idleTime = 0;
        }

        const t = Math.min(this.idleTime * 0.2, 1);

        return {
          x: THREE.MathUtils.lerp(this.input.x, this.idleTarget.x, t),
          y: THREE.MathUtils.lerp(this.input.y, this.idleTarget.y, t)
        };
      }

      updateBreathing(delta) {
        this.breathPhase += delta * 0.5;

        const chest = this.vrm?.humanoid?.getNormalizedBoneNode('chest');
        if (chest) {
          chest.position.y = Math.sin(this.breathPhase) * 0.008;
        }
      }

      updateBlink(delta) {
        this.blinkTimer += delta;

        if (this.blinkTimer >= this.nextBlink && this.vrm?.expressionManager) {
          this.vrm.expressionManager.setValue('blink', 1);

          setTimeout(() => {
            this.vrm?.expressionManager?.setValue('blink', 0);
          }, 120);

          this.blinkTimer = 0;
          this.nextBlink = THREE.MathUtils.randFloat(2, 6);
        }
      }

      updateLookAt(delta, inputX, inputY) {
        if (!this.vrm?.lookAt || !this.lookAtTarget) return;

        this.eyeTarget.x = THREE.MathUtils.lerp(this.eyeTarget.x, inputX * 1.5, delta * 12);
        this.eyeTarget.y = THREE.MathUtils.lerp(this.eyeTarget.y, 1.6 + inputY * 0.5, delta * 12);

        this.lookAtTarget.position.lerp(this.eyeTarget, delta * 12);

        const headEuler = new THREE.Euler(inputY * 0.2, inputX * 0.3, 0, 'XYZ');
        const headRot = new THREE.Quaternion().setFromEuler(headEuler);

        this.headTarget.slerp(headRot, delta * 6);

        this.vrm.lookAt.applyer?.quaternion.slerp(this.headTarget, delta * 60);
        this.vrm.lookAt.update(delta);
      }

      update(delta) {
        if (!this.vrm) return;

        const input = (this.input.x === 0 && this.input.y === 0)
          ? this.updateIdleMovement(delta)
          : this.input;

        this.updateBreathing(delta);
        this.updateBlink(delta);
        this.updateLookAt(delta, input.x, input.y);

        this.vrm.update(delta);
      }

      hideLoader() {
        const loader = document.getElementById('loader');
        loader.style.transition = 'opacity 0.5s ease';
        loader.style.opacity = '0';
        setTimeout(() => loader.remove(), 500);
      }

      onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }

      animate() {
        requestAnimationFrame(() => this.animate());

        const delta = this.clock.getDelta();

        this.update(delta);
        this.renderer.render(this.scene, this.camera);
      }
    }

    new AIAvatar();
  </script>
</body>
</html>