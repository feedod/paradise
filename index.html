<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/",
    "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js"
  }
}
</script>

<style>
:root {
  --bg-color: #000;
  --loader-size: 64px;
  --loader-border: 6px;
}

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background-color: var(--bg-color);
  overflow: hidden;
  font-family: system-ui, sans-serif;
}

canvas {
  display: block;
}

#loader {
  position: fixed;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: var(--bg-color);
  z-index: 100;
}

#progress-spin {
  width: var(--loader-size);
  height: var(--loader-size);
  border: var(--loader-border) solid rgba(255,255,255,0.1);
  border-top-color: #fff;
  border-radius: 50%;
  transform: rotate(0deg);
  animation: rotate-spin 0.1s linear infinite;
}

@keyframes rotate-spin {
  to { transform: rotate(360deg); }
}
</style>
</head>
<body>
<main id="app">
  <div id="loader">
    <div id="progress-spin"></div>
  </div>
</main>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

class Config {
  static LOW_PERFORMANCE = (navigator.deviceMemory || 1) <= 2;
  static MODEL_URL = './models/VRM1_Constraint_Twist_Sample.vrm';
  static CAMERA = { fov: 35, near: 0.1, far: 20, position: [0, 1.5, 3] };
  static PIXEL_RATIO = Config.LOW_PERFORMANCE ? 1 : Math.min(window.devicePixelRatio || 1, 2);
  static BREATH = { speed: Config.LOW_PERFORMANCE ? 0.25 : 0.6, amp: Config.LOW_PERFORMANCE ? 0.008 : 0.015 };
  static BLINK_INTERVAL = { min: Config.LOW_PERFORMANCE ? 8 : 3, max: Config.LOW_PERFORMANCE ? 15 : 7 };
  static MAX_FPS = Config.LOW_PERFORMANCE ? 25 : 60;
  static HEAD_TILT_FACTOR = 0.25;
}

class Utils {
  static clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }
  static lerp(a, b, t) { return a + (b - a) * t; }
  static rand(min, max) { return min + Math.random() * (max - min); }
}

class EventEmitter {
  #listeners = new Map();
  on(event, fn) { (this.#listeners.get(event) ?? this.#listeners.set(event, []).get(event)).push(fn); return this; }
  off(event, fn) { this.#listeners.set(event, (this.#listeners.get(event) ?? []).filter(f => f !== fn)); return this; }
  emit(event, ...args) { (this.#listeners.get(event) ?? []).forEach(fn => fn(...args)); return this; }
}

class Renderer3D extends EventEmitter {
  constructor(container) {
    super();
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(
      Config.CAMERA.fov,
      window.innerWidth / window.innerHeight,
      Config.CAMERA.near,
      Config.CAMERA.far
    );
    this.camera.position.set(...Config.CAMERA.position);

    this.renderer = new THREE.WebGLRenderer({ antialias: !Config.LOW_PERFORMANCE, alpha: true });
    this.renderer.setPixelRatio(Config.PIXEL_RATIO);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.outputColorSpace = THREE.SRGBColorSpace;
    this.renderer.toneMapping = THREE.NoToneMapping;
    container.appendChild(this.renderer.domElement);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.screenSpacePanning = true;
    this.controls.target.set(0, 1, 0);
    this.controls.update();

    const ambient = new THREE.AmbientLight(0xffffff, 0.5);
    const directional = new THREE.DirectionalLight(0xffffff, 1.2);
    directional.position.set(1, 2, 1.5);
    this.scene.add(ambient, directional);

    window.addEventListener('resize', () => this.resize(), { passive: true });
  }

  resize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.emit('resize');
  }

  render() { this.renderer.render(this.scene, this.camera); }
}

class VRMAvatar extends EventEmitter {
  constructor(scene, progressSpin) {
    super();
    this.scene = scene;
    this.vrm = null;
    this.blinkTimer = 0;
    this.nextBlink = Utils.rand(Config.BLINK_INTERVAL.min, Config.BLINK_INTERVAL.max);
    this.breathOffset = Math.random() * Math.PI * 2;
    this.eyeTarget = new THREE.Vector2();
    this.headTilt = new THREE.Vector2();
    this.progressSpin = progressSpin;
  }

  async load(url) {
    const loader = new GLTFLoader();
    loader.register(parser => new VRMLoaderPlugin(parser));

    const gltf = await new Promise((resolve, reject) => {
      loader.load(url,
        gltf => resolve(gltf),
        progress => {
          if (progress.total) {
            const percent = Math.min((progress.loaded / progress.total) * 360, 360);
            this.progressSpin.style.transform = `rotate(${percent}deg)`;
          }
        },
        err => reject(err)
      );
    });

    if (!gltf.userData.vrm) throw new Error('VRM not found');

    VRMUtils.removeUnnecessaryVertices(gltf.scene);
    VRMUtils.combineSkeletons(gltf.scene);
    VRMUtils.combineMorphs(gltf.userData.vrm);

    this.vrm = gltf.userData.vrm;

    this.vrm.scene.position.set(0, -1, 0);
    this.vrm.scene.rotation.y = Math.PI;

    const bbox = new THREE.Box3().setFromObject(this.vrm.scene);
    const size = new THREE.Vector3();
    bbox.getSize(size);
    const maxDim = Math.max(size.x, size.y, size.z);
    const scaleFactor = 2 / maxDim;
    this.vrm.scene.scale.setScalar(scaleFactor);

    this.vrm.scene.traverse(obj => obj.frustumCulled = false);
    this.scene.add(this.vrm.scene);
    this.emit('loaded', this.vrm);
  }

  setExpression(name, value) {
    this.vrm?.blendShapeProxy?.setValue(name, value);
  }

  update(dt) {
    if (!this.vrm) return;
    this.blinkTimer += dt;
    if (this.blinkTimer > this.nextBlink) {
      this.setExpression('blink', 1);
      setTimeout(() => this.setExpression('blink', 0), 120);
      this.blinkTimer = 0;
      this.nextBlink = Utils.rand(Config.BLINK_INTERVAL.min, Config.BLINK_INTERVAL.max);
    }

    const chest = this.vrm.humanoid.getNormalizedBoneNode('chest');
    if (chest) chest.position.y = Math.sin(Date.now() * 0.001 * Config.BREATH.speed + this.breathOffset) * Config.BREATH.amp;

    const head = this.vrm.humanoid.getNormalizedBoneNode('head');
    if (head) {
      const lerpFactor = Config.LOW_PERFORMANCE ? 1.2 : 2.5;
      head.rotation.y = Utils.lerp(head.rotation.y, this.headTilt.x, dt * lerpFactor);
      head.rotation.x = Utils.lerp(head.rotation.x, this.headTilt.y, dt * lerpFactor);
    }
  }
}

class ParadiseAI {
  constructor(container) {
    this.renderer = new Renderer3D(container);
    const progressSpin = document.getElementById('progress-spin');
    this.avatar = new VRMAvatar(this.renderer.scene, progressSpin);
    this.clock = new THREE.Clock();
    this.lastFrame = 0;
    this.isTouching = false;

    this.avatar.on('loaded', () => this.hideLoader());
    this.initTouchControls();
  }

  hideLoader() {
    document.getElementById('loader').remove();
  }

  initTouchControls() {
    const update = (x, y) => {
      const nx = (x / window.innerWidth - 0.5) * 2;
      const ny = -(y / window.innerHeight - 0.5) * 2;
      this.avatar.eyeTarget.set(nx * 0.5, ny * 0.5);
      this.avatar.headTilt.set(nx * Config.HEAD_TILT_FACTOR, ny * Config.HEAD_TILT_FACTOR);
    };

    const start = e => { this.isTouching = true; update(e.touches[0].clientX, e.touches[0].clientY); };
    const move = e => { if (this.isTouching) update(e.touches[0].clientX, e.touches[0].clientY); };
    const end = () => { this.isTouching = false; this.avatar.eyeTarget.set(0, 0); this.avatar.headTilt.set(0, 0); };

    document.addEventListener('touchstart', start, { passive: true });
    document.addEventListener('touchmove', move, { passive: true });
    document.addEventListener('touchend', end);
  }

  async start() {
    await this.avatar.load(Config.MODEL_URL);
    this.loop();
  }

  loop() {
    requestAnimationFrame(() => this.loop());
    const now = performance.now();
    let dt = (now - this.lastFrame) / 1000;
    if (dt < 1 / Config.MAX_FPS) return;
    this.lastFrame = now;

    this.avatar.update(dt);
    this.renderer.render();
  }
}

new ParadiseAI(document.getElementById('app')).start();

</script>
</body>
</html>